<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pen Int Style - Multiple 67s</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // --- 狀態管理 ---
        // 存放所有已經完成或正在變形的圖形物件
        // 格式: { targetPoints: [], currentPoints: [], startTime: null, finished: false }
        let shapes = [];

        // 正在繪製的原始路徑
        let isDrawing = false;
        let currentRawPath = [];

        // 動畫持續時間
        const MORPH_DURATION = 700;

        // ------------------------------------------------------------
        // 1. 定義標準化的 "67" 幾何形狀 (Normalized Geometry)
        // ------------------------------------------------------------
        // 我們在一個假想的 1x1 的單位方塊中定義 67 的筆畫
        // 這樣之後就可以方便地縮放和移動到任何位置
        const normalizedStrokes = [
            // --- 筆畫 1: "6" ---
            // [起點x,y, 控制點1x,y, 控制點2x,y, 終點x,y] (貝茲曲線)
            [0.4, 0.0, 0.2, 0.0, 0.0, 0.3, 0.0, 0.6], // 上半部弧線
            [0.0, 0.6, 0.0, 1.0, 0.5, 1.0, 0.5, 0.6], // 下半部圓圈底
            [0.5, 0.6, 0.5, 0.3, 0.2, 0.4, 0.1, 0.6], // 下半部圓圈收尾

            // --- 筆畫 2: "7" 的橫 ---
            // 這裡使用直線段，用兩個控制點相同的貝茲曲線表示
            [0.6, 0.0, 0.7, 0.0, 0.8, 0.0, 1.0, 0.0],

            // --- 筆畫 3: "7" 的撇 ---
            [1.0, 0.0, 0.9, 0.3, 0.8, 0.7, 0.7, 1.0]
        ];

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);

        // ------------------------------------------------------------
        // 2. 核心工具函數 (Geometry & Resampling Utils)
        // ------------------------------------------------------------

        // 將貝茲曲線定義轉換成密集的點陣列
        function getPointsFromBeziers(strokes, scale, offsetX, offsetY) {
            let points = [];
            const POINTS_PER_SEGMENT = 20; // 解析度

            strokes.forEach(segment => {
                for (let i = 0; i <= POINTS_PER_SEGMENT; i++) {
                    const t = i / POINTS_PER_SEGMENT;
                    // 貝茲公式應用縮放和位移
                    const x = ((1 - t) ** 3 * segment[0] + 3 * (1 - t) ** 2 * t * segment[2] + 3 * (1 - t) * t ** 2 * segment[4] + t ** 3 * segment[6]) * scale + offsetX;
                    const y = ((1 - t) ** 3 * segment[1] + 3 * (1 - t) ** 2 * t * segment[3] + 3 * (1 - t) * t ** 2 * segment[5] + t ** 3 * segment[7]) * scale + offsetY;
                    points.push({ x, y });
                }
                // 重要：在不同筆畫之間插入一個「斷點」標記，用於繪圖時斷開連接
                // 但為了重採樣算法，物理上它們在陣列裡是連續的
                if (points.length > 0) {
                    points[points.length - 1].endOfStroke = true;
                }
            });
            return points;
        }

        // 計算路徑的邊界框 (Bounding Box)
        function getBoundingBox(path) {
            if (path.length === 0) return { x: 0, y: 0, w: 100, h: 100 };
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return {
                x: minX,
                y: minY,
                w: Math.max(50, maxX - minX), // 防止太小
                h: Math.max(50, maxY - minY)
            };
        }

        // 核心：路徑重採樣 (確保點數一致以進行變形)
        function resamplePath(path, targetCount) {
            if (path.length < 2) return Array(targetCount).fill(path[0] || { x: 0, y: 0 });

            let totalLength = 0;
            for (let i = 1; i < path.length; i++) {
                totalLength += Math.hypot(path[i].x - path[i - 1].x, path[i].y - path[i - 1].y);
            }

            const step = totalLength / (targetCount - 1 || 1);
            let newPath = [path[0]];
            let currentDist = 0;
            let nextStepDist = step;

            for (let i = 0; i < path.length - 1; i++) {
                let p1 = path[i];
                let p2 = path[i + 1];
                let segmentDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                while (currentDist + segmentDist > nextStepDist) {
                    let t = (nextStepDist - currentDist) / segmentDist;
                    newPath.push({
                        x: p1.x + (p2.x - p1.x) * t,
                        y: p1.y + (p2.y - p1.y) * t
                    });
                    nextStepDist += step;
                }
                currentDist += segmentDist;
            }
            while (newPath.length < targetCount) newPath.push(path[path.length - 1]);
            return newPath.slice(0, targetCount);
        }

        // ------------------------------------------------------------
        // 3. 主迴圈與繪圖 (Main Loop & Rendering)
        // ------------------------------------------------------------
        function loop(timestamp) {
            ctx.clearRect(0, 0, width, height);

            // A. 繪製所有已存在的形狀 (變形中 或 已完成)
            shapes.forEach(shape => {
                if (!shape.finished) {
                    // 計算變形進度
                    let progress = (timestamp - shape.startTime) / MORPH_DURATION;
                    if (progress >= 1) {
                        progress = 1;
                        shape.finished = true; // 標記為完成
                    }
                    // Ease Out 動畫曲線
                    const ease = progress * (2 - progress);

                    // 更新當前點的位置 (插值)
                    for (let i = 0; i < shape.currentPoints.length; i++) {
                        const start = shape.startPoints[i];
                        const end = shape.targetPoints[i];
                        shape.currentPoints[i].x = start.x + (end.x - start.x) * ease;
                        shape.currentPoints[i].y = start.y + (end.y - start.y) * ease;
                        // 繼承目標點的斷點屬性，這樣變形完成後就會斷開
                        shape.currentPoints[i].endOfStroke = end.endOfStroke;
                    }
                }

                // 繪製這個形狀
                drawFancyPath(shape.currentPoints, shape.finished);
            });

            // B. 繪製使用者正在畫的原始紅色路徑
            if (isDrawing) {
                ctx.beginPath();
                if (currentRawPath.length > 0) {
                    ctx.moveTo(currentRawPath[0].x, currentRawPath[0].y);
                    for (let i = 1; i < currentRawPath.length; i++) {
                        ctx.lineTo(currentRawPath[i].x, currentRawPath[i].y);
                    }
                }
                ctx.strokeStyle = '#ff3333';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 0;
                ctx.stroke();
            }

            requestAnimationFrame(loop);
        }

        // 繪製帶有發光效果和支援斷點的路徑
        function drawFancyPath(points, isFinished) {
            if (points.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < points.length; i++) {
                const p = points[i];
                const prevP = points[i - 1];

                // 如果前一個點是筆畫結尾，這裡要斷開，重新 moveTo
                if (prevP.endOfStroke && isFinished) {
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }

            ctx.strokeStyle = isFinished ? '#eee' : '#aaa'; // 完成變白，變形中灰色
            ctx.lineWidth = isFinished ? 4 : 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = isFinished ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.2)';
            ctx.shadowBlur = isFinished ? 15 : 5;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }


        // ------------------------------------------------------------
        // 4. 事件監聽 (Input Handling)
        // ------------------------------------------------------------
        function startDraw(x, y) {
            isDrawing = true;
            currentRawPath = [{ x, y }];
        }

        function moveDraw(x, y) {
            if (!isDrawing) return;
            const last = currentRawPath[currentRawPath.length - 1];
            // 簡單防抖
            if (Math.hypot(x - last.x, y - last.y) > 4) {
                currentRawPath.push({ x, y });
            }
        }

        function endDraw() {
            if (!isDrawing) return;
            isDrawing = false;

            if (currentRawPath.length < 5) return; // 太短不處理

            // --- 關鍵步驟：動態生成目標 ---

            // 1. 計算使用者畫的範圍
            const bbox = getBoundingBox(currentRawPath);
            const scale = Math.max(bbox.w, bbox.h); // 保持比例

            // 2. 根據範圍，生成專屬的 "67" 目標點
            const specificTargetPoints = getPointsFromBeziers(
                normalizedStrokes,
                scale,   // 縮放
                bbox.x,  // 位移 X
                bbox.y   // 位移 Y
            );

            // 3. 將使用者畫的線重新採樣，使其點數與目標一致
            const resampledStartPoints = resamplePath(currentRawPath, specificTargetPoints.length);

            // 4. 創建新的形狀物件並加入陣列
            shapes.push({
                startPoints: resampledStartPoints.map(p => ({ ...p })), // 複製起始點
                currentPoints: resampledStartPoints.map(p => ({ ...p })), // 用於動畫的當前點
                targetPoints: specificTargetPoints, // 目標點
                startTime: performance.now(),
                finished: false
            });

            currentRawPath = []; // 清空原始路徑
        }

        // 滑鼠與觸控事件綁定
        canvas.addEventListener('mousedown', e => startDraw(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => moveDraw(e.clientX, e.clientY));
        window.addEventListener('mouseup', endDraw);

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            startDraw(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            moveDraw(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        window.addEventListener('touchend', endDraw);

        // 啟動
        resize();
        requestAnimationFrame(loop);

    </script>
</body>

</html>
